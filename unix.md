# Интерфейсы операционной системы

Работа **операционной системы** *(англ. operation system)* заключается в разделении компьютера между несколькими программами и предоставлении более практичного набора сервисов, чем это обеспечивает **аппаратное обеспечение** *(англ. hardware)* в одиночку. **Операционная система** управляет и абстрагирует **аппаратное обеспечение** низкого уровня. Таким образом, например, текстовый процессор не должен беспокоиться о том, какой тип дискового оборудования используется. Операционная система разделяет аппаратное обеспечение между несколькими программами, чтобы они работали (или казались работающими) одновременно. Наконец, операционные системы предоставляют контролируемые способы взаимодействия программ,
с помощью которых они могут обмениваться данными и работать вместе.

Операционная система предоставляет сервисы пользовательским программам через **интерфейс**. И, оказывается, что разработка хорошего интерфейса является сложной задачей. С одной стороны, желательно, чтобы интерфейс был простым и компактным, потому что это облегчает правильную реализацию. С другой стороны, соблазнительно расширить функционал множеством удобных, но сложных функций. Хитрость в разрешении этого противоречия заключается в разработке интерфейсов, которые базируются на нескольких простых механизмах, которые могут быть комбинированы для обеспечения большой общности и абстракции.

Эта книга использует единственную операционную систему для иллюстрации концепций операционных систем. Данная операционная система (**xv6**) предоставляет базовые интерфейсы, введённые операционной системой [Unix](UNIX_LINK) Кена Томпсона и Денниса Ричи, а также имитирует внутреннее устройство **Unix**. Unix обеспечивает компактный интерфейс, механизмы которого удобно комбинируются, предоставляя поразительную общность. Этот интерфейс был настолько успешен, что современные операционные системы - BSD, Linux, macOS, Solaris и даже, в небольшой степени, Microsoft Windows - имеют похожие на Unix интерфейсы. Понимание xv6 — это хороший старт для понимания любой из этих систем и многих других.

 [](fig:os)

Как показано на рисунке, xv6 имеет традиционную форму **ядра** *(англ. kernel)* - специальной программы, которая предоставляет обслуживание работающим программам. Каждая работающая **программа** называется **процессом** *(англ. process)*. У каждого процесса свои: **память**, содержащая инструкции, **данные** и **стек**. **Инструкции** реализуют вычисления программы. **Данные** — это переменные, над которыми выполняются вычисления. **Стек** организует вызовы процедур программы. На одном компьютере обычно работает много **процессов**, но только одно **ядро** операционной системы.

Когда процессу необходимо обратиться к ядру, он совершает **системный вызов** *(англ. system call)*. **Системный вызов** — это одна из возможностей обратиться к операционной системе через предоставленный интерфейс. Системный вызов выглядит как вызов подпрограммы или функции из системной библиотеки. При использовании, он входит в ядро, выполняет требуемую операцию и возвращается в то место откуда был вызван. Таким образом, процесс чередует исполнение в **пользовательском пространстве** *(англ. user space)* и **пространстве ядра** *(англ. kernel space)*.

В последующих главах будет описано, как ядро использует механизмы аппаратной защиты, предоставляемые **центральным процессором** *(англ. central processor unit - CPU), чтобы запретить доступ процессов к памяти, принадлежащей другим процессам на компьютере.

 > Термин **центральный процессор (ЦП, CPU)** в целом относится к аппаратному элементу, выполняющему вычисления. В некоторых источниках (например, спецификации RISC-V) также используются слова **процессор** *(англ. processor)*, **ядро** *(англ. core)*, и **сердце** *(англ. heart)* вместо **ЦП**.

Ядро работает с необходимыми аппаратными привилегиями для реализации этих механизмов защиты. Пользовательские же программы выполняются без таких привилегий. Когда пользовательская программа совершает системный вызов, аппаратура повышает уровень привилегий и начинает выполнение специальной подпрограммы для подготовки переключения дальнейшего исполнения в пространство ядра.

[](fig/os.pdf)
*Ядро и два пользовательских процесса.*

Совокупность системных вызовов, которые предоставляет ядро, является интерфейсом, который видят пользовательские программы. Ядро xv6 предоставляет подмножество возможностей и системных вызовов, которые традиционно предоставляют ядра Unix. На рисунке [](fig:api) перечислены все системные вызовы xv6.

Остальная часть этой главы описывает **сервисы** xv6 — процессы, память, дескрипторы файлов, каналы и файловую систему - и иллюстрирует их фрагментами кода и обсуждением того, как **оболочка** *(англ. shell)* - пользовательский интерфейс командной строки UNIX, использует их. Применение системных вызовов оболочкой демонстрирует, насколько тщательно они были разработаны.

**Оболочка** — это обычная программа, которая читает команды от пользователя и выполняет их. Тот факт, что оболочка является пользовательской программой и не является частью ядра, иллюстрирует мощь интерфейса системных вызовов: в оболочке нет ничего особенного по сравнению с любыми другими пользовательскими процессами. Это также означает, что оболочку легко заменить. В результате в современных UNIX-системах доступно множество оболочек на выбор, каждая со своим пользовательским интерфейсом и возможностями скриптового языка. Оболочка xv6 — это упрощенная реализация оригинальной оболочки UNIX Bourne. Ее исходный код можно найти в файле *user/sh.c*.

## Процессы и память

**Процессы** в xv6 состоят из пользовательской памяти (инструкций, данных и стека) и состояния процесса, хранящегося внутри ядра и недоступного для пользователя. Ядро xv6 выполняет разделение времени между процессами: оно автоматически переключает доступный процессор на один из процессов, ожидающих выполнения. Когда процесс не выполняется, xv6 сохраняет регистры процесса, и восстанавливает их при следующем запуске процесса. Каждому процессу соответствует уникальный **идентификатор процесса** *(англ. PID - process identifier)*. На одном **процессоре** выполняется всегда только один **процесс**. Другие процессы находятся в состоянии ожидания до тех пор, пока ядро не решит переключить исполнение на них.

|  Системный вызов  | описание  |
|:------------------|:----------|
| int fork() | Создает новый процесс, родителю возвращает идентификатор дочернего процесса. У ребенка статус возврата - 0. |
| int exit(int status) | Завершает текущий процесс. Статус возврата считывается вызовом wait(). Функция не возвращается. |
| int wait(int \*status) | Ждет завершения любого дочернего процесса. Статус возврата ребенка помещается в *\*status*. Возвращает идентификатор процесса завершившегося ребенка. |
| int kill(int pid) | Завершает процесс с идентификатором pid, возвращает 0, или -1 при ошибке. |
| int getpid() | Возвращает идентификатор *(pid)* текущего процесса. |
| int sleep(int n) | Останавливает исполнение на n системных тактов. |
| int exec(char \*file, char \*argv[]) | Загрузить исполняемый файл и запустить его с аргументами (заменив текущий процесс). Функция возвращается только при ошибке. |
| char \*sbrk(int n) | Увеличивает размер принадлежащей процессу памяти на *n* байт. Возвращает старую границу (которая теперь является началом нового предоставленного участка памяти). |
| int open(char \*file, int flags) | Открывает файл с заданными флагами, возвращает дескриптор открытого файла, или -1 при ошибке. |
| int write(int fd, char \*buf, int n) | Записывает n байт из буфера в файловый дескриптор *fd*. Возвращает количество записанных байт, или -1 при ошибке. |
| int read(int fd, char \*buf, int n) | Считывает из файлового дескриптора *fd* в буфер *n* байт. Возвращает количество записанных байт, 0 если достигнут конец файла, или -1 при ошибке. |
| int close(int fd) | Закрывает файл, и освобождает дескриптор *fd*. |
| int dup(int fd) | Возвращает новый дескриптор, ссылающийся на то же место в файле что и *fd*. |
| int pipe(int p[2]) | Создает безымянный канал между двумя дескрипторами, помещает созданные дескрипторы на чтение/запись в *p[0]*/*p[1]*. |
| int chdir(char \*dir) | Изменяет текущую рабочую директорию. |
| int mkdir(char \*dir) | Создает новый пустой каталог. |
| int mknod(char \*file, int, int) | Создает новый файл устройства. |
| int fstat(int fd, struct stat \*st) | Помещает информацию об открытом файле с дескриптором *fd* в структуру по указателю *st*. |
| int stat(char \*file, struct stat \*st) | Помещает информацию о файле с именем *file* в структуру по указателю st. |
| int link(char \*file1, char \*file2) | Создает альтернативное имя *file2* (жесткую ссылку) для файла *file1*. |
| int unlink(char \*file) | Удаляет файл *file*. |

Процесс может создать новый процесс,
используя системный вызов `fork`. `Fork` предоставляет новому процессу точную копию памяти, инструкций, и данных вызывающего процесса. `Fork` возвращается как в исходном, так и в новом процессах. В исходном процессе `fork` возвращает идентификатор созданного процесса. В созданном процессе `fork` возвращает ноль. Исходный и новый процессы обычно называются **родительским** *(англ. parent)* и **дочерним** *(англ. child)*. К примеру, рассмотрим следующий фрагмент программы, написанный на языке программирования [Си](kernighan):

```c++
int pid = fork();
if (pid > 0) {
        printf("parent: child=%d\n", pid);
        pid = wait(NULL);
        printf("child %d is done\n", pid);
} else if (pid == 0) {
        printf("child: exiting\n");
        exit(0);
} else {
        printf("fork error\n");
}
```

Системный вызов `exit` приводит к прекращению выполнения вызывающего процесса и освобождению ресурсов, таких как память и открытые файлы. `Exit' принимает целочисленный аргумент - статус возврата, обычно 0 указывает на успех, а другие значения на ошибку.

Системный вызов `wait` возвращает идентификатор последнего завершенного (или уничтоженного) дочернего процесса и помещает статус завершения дочернего процесса по указателю, переданному в качестве аргумента в `wait`. Если еще ни один из дочерних процессов не завершился, `wait` ожидает завершения любого из дочерних процессов. Если у вызывающего процесса нет дочерних процессов, `wait` возвращает -1 без ожидания. Если родительский процесс не нуждается в статусе возврата дочернего элемента, он может передать *NULL* в качестве аргумента системного вызова.

В приведенном выше примере напечатанные строки могут выводиться в любом порядке (или даже смешаться), в зависимости от того, кто из родителей или дочерних процессов первым выполнит свой вызов `printf`. После завершения дочернего процесса возвращается родительский вызов `wait`, в результате чего родительский процесс выводит:
```
child 1234 is done.
```
Хотя дочерний процесс изначально имеет то же содержимое памяти, что и родительский (дочерний процесс получает свое собственное адресное пространство - точную копию родительского, включая исполняемые инструкции, значения всех переменных и указателей), дочерний процесс никак не связан с памятью родительского процесса, и никак не может взаимодействовать с ней. Кроме того, у каждого процесса будут собственные регистры: изменение переменной в одном из процессов не влияет на переменную в другом. Например, когда возвращаемое значение `wait` сохраняется в переменную *pid* родительского процесса, это не изменяет переменную *pid* в дочернем процессе. Значение *pid* в дочернем элементе по-прежнему будет равно нулю.

Системный вызов `exec` заменяет память текущего процесса новым образом памяти, загруженным из файла, хранящегося в файловой системе. Файл должен иметь определенный формат, который определяет, какая часть файла содержит инструкции, какая часть является данными, с какой команды начинать и т.д. Xv6 использует формат **ELF**, который более подробно обсуждается в главе [Memory](memory). Обычно файл является результатом компиляции исходного кода программы. Когда `exec` завершается успешно, он не возвращается к вызывающей программе. Вместо этого, далее начинают исполняться уже инструкции из загруженные из файла, начиная из точки входа, объявленной в заголовке **ELF**. `exec` принимает два аргумента: имя исполняемого файла, и массив аргументов командной строки. Например:
```c++
char *argv[3];

argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```
этот фрагмент кода заменяет вызывающую программу экземпляром программы */bin/echo*, запущенной со списком аргументов **"echo"**, **"hello"**. Большинство программ не используют первый элемент массива аргументов, который обычно является именем исполняемого файла.

Оболочка *(англ. shell)* xv6 использует вышеуказанные системные вызовы для запуска программ от имени пользователя. Основная структура оболочки проста (см. *user/sh.c:main*). Основной цикл считывает строку ввода от пользователя с помощью функции `getcmd`. Затем он вызывает `fork`, который создает копию процесса оболочки. Родительский процесс вызывает `wait`, в то время как дочерний процесс исполняет команду. Пользовательская команда исполняется в функции `runcmd` (см. *user/sh.c:runcmd*). Например, если пользователь наберет в командной строке:
```bash
echo hello
```
Функция `runcmd` вызовется с **"echo hello"** в качестве аргумента и вызовет системный вызов `exec` (см. *user/sh.c:exececmd*), который подменит дочерний процесс на исполняемый файл echo с аргументами **"echo"** и **"hello"**. В конце работы процесс *echo* вызовет системный вызов `exit`, что приведет к возвращению системного вызова `wait` в родительском процессе (см. *user/sh.c:main*). И дальше оболочка считывает следующую команду.

Вы можете задаться вопросом, почему `fork` и `exec` не объединены в одном системном вызове. Позже мы увидим, что это разделение очень удобно для реализации перенаправления ввода-вывода в оболочке. Чтобы избежать расточительности создания дубликата целого процесса и моментальной  замены его на другой процесс, операционные системы оптимизируют реализацию `fork` для таких случаев, используя возможности виртуальной памяти, такие как копирование при записи *(англ. copy-on-write)* (см. раздел [pagefaults](pagefaults)).

Xv6 выделяет большую часть памяти адресного пространства пользовательского процесса неявно: `fork` выделяет только память, для копии памяти родительского процесса, а `exec` выделяет только память для хранения исполняемого файла. Процесс, которому требуется больше памяти во время выполнения (возможно, для аллокации памяти при помощи `malloc`), может вызвать системный вызов `sbrk(n)`, чтобы увеличить объем своей памяти на *n* байт. `Sbrk` увеличивает размер принадлежащей процессу памяти на *n* байт. Системный вызов возвращает старую границу памяти, которая теперь является началом нового предоставленного участка памяти.

## Ввод-вывод и файловые дескрипторы

**Файловый дескриптор** — это небольшое целое число, представляющее объект, управляемый ядром, с которым процесс может выполнять операции чтения или записи. Процесс может получить **файловый дескриптор**, открыв файл, каталог или устройство, или создав **канал** *(англ. pipe)*, или скопировав существующий дескриптор. Для простоты мы будем называть объект, на который ссылается файловый дескриптор просто **файлом**. Интерфейс файлового дескриптора абстрагирует различия между **файлами**, **каналами** и **устройствами**, делая их все похожими на потоки байтов. Мы будем называть ввод и вывод **I/O** *(англ. Input/Output)*.

Ядро xv6 использует файловый дескриптор в качестве индекса в таблице для каждого процесса, так что у каждого процесса есть личное пространство файловых дескрипторов, начинающееся с нуля. По соглашению, **стандартный ввод** (ввод из консоли) имеет дескриптор *0*, **стандартный вывод** (вывод в консоль) - дескриптор *1*, и стандартный **поток ошибок** (он тоже выводится в консоль вместе со стандартным выводом) имеет дескриптор *2*. Как мы увидим, оболочка использует это соглашение для реализации перенаправления ввода-вывода и конвейеров команд. Оболочка гарантирует, что у нее всегда открыты три файловых дескриптора (см. *user/sh.c:openconsole*),
которые по умолчанию являются файловыми дескрипторами для консоли.

Системные вызовы `read` и `write` считывают байты и записывают байты в открытые файлы, используя соответствующие им файловые дескрипторы. Вызов `read(fd, buf, n)` считывает не более *n* байт из файлового дескриптора *fd*, копирует их в *buf* и возвращает количество прочитанных байт. Каждый файловый дескриптор, который ссылается на файл, имеет свою позицию в файле. `read` считывает данные с текущей позиции, а затем смешает ее на количество прочитанных байт. Таким образом, последующие вызовы `read` вернут данные, следующие за теми, которые были получены предыдущими вызовами `read`. Когда больше нет байтов для чтения, `read` возвращает *0*, указывающий на конец файла.

Системный вызов `write(fd, buf, n)` записывает *n* байт из области памяти, на которую указывает *buf* в файловый дескриптор *fd* и возвращает количество записанных байт. Меньше, чем *n* байт может быть записано только при возникновении ошибки. Как и системный вызов `read` - `write` записывает данные по текущему смещению в файле, а затем увеличивает это смещение на количество записанных байт, то есть каждый следующий вызов `write` записывает с того места, где закончил предыдущий.

Следующий фрагмент программы (который реализует суть программы `cat`) копирует данные из потока стандартного ввода в поток стандартного вывода. Если возникает ошибка, он записывает сообщение в поток стандартной ошибки.

```c++
char buf[512];
int n;

while (1) {
    n = read(0, buf, sizeof(buf));
    if (n == 0) {
        break;
    } else if (n < 0) {
        fprintf(2, "read error\n");
        exit(1);
    }

    if (write(1, buf, n) != n) {
        fprintf(2, "write error\n");
        exit(1);
    }
}
```
Важная вещь, которую следует отметить, что программа не знает, читает ли она из **файла**, **консоли** или **канала** *(англ. pipe)*. Точно так же она не знает, печатает ли она в консоль, в файл или что-то еще. Использование файловых дескрипторов и соглашение о том, что файловый дескриптор *0* является стандартным вводом, а файловый дескриптор *1* - стандартным выводом, позволяет так просто реализовать `cat`.

Системный вызов `close` освобождает файловый дескриптор, делая его доступным для повторного использования для будущих системных вызовов, таких как `open`, `pipe` или `dup` (см. ниже). Новый созданный файловый дескриптор всегда является неиспользуемым дескриптором текущего процесса с наименьшим номером.

Такое взаимодействие файловых дескрипторов и системного вызова `fork` позволяют очень просто реализовать **перенаправление ввода-вывода** *(англ. I/O redirection)*. `fork` копирует таблицу файловых дескрипторов родительского файла вместе с его памятью, так что дочерний файл запускается точно с теми же открытыми файлами, что и родительский. Системный вызов `exec` заменяет память вызывающего процесса, но оставляет его файловую таблицу без изменений. Такое поведение позволяет оболочке реализовать перенаправление ввода-вывода путем разветвления (т.е. вызова `fork`), открытия выбранных файловых дескрипторов в дочернем файле за место стандартных дескрипторов (ввода, вывода и ошибки), а затем вызова `exec` для запуска новой программы. Вот упрощенная версия кода, выполняемого оболочкой:

```c++
char *argv[] = { "cat", NULL };

if (fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
```
Если пользователь введёт в оболочку команду:

```bash
cat < input.txt"
```
После того, как дочерний процесс закроет файловый дескриптор *0*, системный вызов `open` гарантированно будет использовать этот файловый дескриптор, так как `open` всегда выбирает наименьший свободный дескриптор для открываемого файла. Таким образом, теперь дескриптор *0* указывает не на стандартный поток ввода, а на открытый файл *input.txt*. Затем `cat` выполняется и читает из стандартного потока ввода (файлового дескриптор *0*). Но так как стандартный поток ввода был до этого перенаправлен - чтение будет происходить из файла "input.txt".
 > см. `man cat`: программа без аргументов просто копирует стандартный поток ввода в стандартный поток вывода.

Изменение файловых дескрипторов влияет только на текущий и все будущие дочерние процессы. Дескрипторы родительского процесса таким способом не изменяются (и вообще нет способа изменить родительские файловые дескрипторы).

Код для перенаправления ввода-вывода в оболочке xv6 работает именно таким образом (см. *user/sh.c:case.REDIR*). Напомним, что на этом этапе код оболочки уже вызвал системный вызов `fork` и в дочернем процессе функция `runcmd` собирается вызвать `exec` для загрузки новой программы.

Второй аргумент `open` состоит из набора флагов, выраженных в виде битов, которые управляют тем, что делает `open`. Возможные значения определены в заголовке управления файлами (см. *kernel/fcntl.h*) *(fcntl от англ. file control)*: `O_RDONLY` - открывает файл только для чтения, `O_WRONLY` - открывает файл только для записи, `O_RDWR` - открывает файл и для чтения и для записи, `O_CREATE` - создает файл если он не существует, `O_TRUNC` - очищает содержимое файла.

Теперь должно быть ясно, почему полезно, чтобы `fork` и `exec` были отдельными вызовами: между ними у оболочки есть шанс перенаправить ввод-вывод дочернего процесса, не нарушая ввода-вывода основной оболочки. Вместо этого можно было бы представить гипотетический комбинированный системный вызов `forkexec`, но варианты выполнения перенаправления ввода-вывода с помощью такого вызова кажутся неудобными. Оболочка могла бы изменить свои собственные настройки ввода-вывода перед вызовом `forkexec`, а затем отменить эти изменения. Или `forkexec` мог бы принимать инструкции для перенаправления ввода-вывода в качестве аргументов, или (наименее привлекательно) каждой программе, подобной `cat`, пользователю приходилось бы указывать как выполнять операции перенаправления ввода-вывода.

Хотя `fork` копирует таблицу файловых дескрипторов, смещение каждого файлового дескриптора остается общим для родительского и дочернего файлов. Рассмотрим такой пример:

```c++
if (fork() == 0) {
    write(1, "hello ", 6);
    exit(0);
} else {
    wait(0);
    write(1, "world\n", 6);
}
```
В конце этого фрагмента файл, соответствующий файловому дескриптору *1*, будет содержать данные
```
hello world
```
`write` в родительском процессе (который, благодаря `wait`, запустится только после завершения дочернего процесса) начнет записывать с того места, где остановился `write` дочернего процесса. Такое поведение помогает производить последовательный вывод из нескольких команд оболочки, например:
```bash
{ echo hello; echo world } > output.txt
```
Системный вызов `dup` дублирует существующий файловый дескриптор, возвращая новый, который ссылается на тот же исходный объект ввода-вывода. Оба файловых дескриптора имеют общее смещение, точно так же, как и файловые дескрипторы, дублируемые с помощью `fork`. Вот еще один способ записать "hello world" в файл:
```c++
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
```
Два файловых дескриптора имеют общее смещение, если они были получены из одного и того же исходного файлового дескриптора благодаря `fork` или `dup`. В противном случае файловые дескрипторы не имеют общих смещений, даже если они получены в результате вызовов `open` для одного и того же файла. `dup` позволяет оболочкам реализовывать команды, подобные этой:
```bash
ls existing-file non-existing-file > tmp 2>&1
```
Фрагмент `2>&1` указывает командной оболочке использовать для файлового дескриптора *2* дубликат дескриптора *1*. Таким образом имя существующего файла, и сообщение об ошибке для несуществующего файла будут оба отображаться в файле `tmp1`. Оболочка xv6 не поддерживает перенаправление ввода-вывода для файлового дескриптора ошибки, но теперь вы знаете, как это реализовать.

Файловые дескрипторы являются мощной абстракцией, поскольку они скрывают детали того, к чему они подключены: процесс, записывающий в файловый дескриптор *1*, может на самом деле выполнять запись в файл, на устройство, такое как консоль, или в канал.

## Безымянные каналы

**Канал** *(англ. pipe)* — это небольшой буфер в ядре, доступный процессам в виде пары файловых дескрипторов, один для **чтения**, другой для **записи**. После записи данных в один конец канала они становятся доступными для чтения с другого конца канала. Каналы обеспечивают способ **межпроцессного взаимодействия** *(англ. interprocess communication)*.

Следующий пример кода запускает программу `wc`, подключив ее стандартный ввод к концу канала для чтения.
```c++
int p[2];
char *argv[2];

argv[0] = "wc";
argv[1] = NULL;

pipe(p);
if (fork() == 0) {
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    close(p[0]);
    write(p[1], "hello world\n", 12);
    close(p[1]);
}
```
Программа вызывает системный вызов `pipe`, который создает канал и записывает файловые дескрипторы чтения и записи в массив p *(см. `man pipe`: p[0] является дескриптором на чтение, а p[1] - дескриптором на запись)*. После вызова `fork` как родительский, так и дочерний процессы владеют дескрипторами, ссылающиеся на канал. Дочерний процесс вызывает `close(0)` чтобы закрыть стандартный поток ввода, а затем `dup(p[0])`, чтобы дублировать конец канала для чтения в только что освободившийся дескриптор *0*. Так же, дочерний процесс закрывает лишние файловые дескрипторы в `p` (для избежания утечки дескрипторов) и вызывает системный вызов `exec` для запуска команды `wc`. Таким образом когда `wc` считывает из своего стандартного ввода, он на самом деле считывает из канала. Родительский процесс, в свою очередь, закрывает сторону канала для чтения (опять же для избежания утечки дескрипторов), выполняет запись в канал, а затем закрывает сторону записи.

Если в канале нет данных для чтения, `read` ожидает либо записи данных с другой стороны канала, либо закрытия всех файловых дескрипторов, ссылающихся на конец для записи. Во втором случае `read` вернет *0*, точно так же, как если бы был достигнут конец файла. Тот факт, что чтение блокируется до тех пор, пока поступление новых данных не станет невозможным, является одной из причин, по которой дочернему процессу важно закрыть конец канала записи перед выполнением, описанного выше кода `wc`. Если бы один из файловых дескрипторов в `wc` ссылался на конец канала записи, `wc` никогда бы не увидел конец файла, и программа бы зависла.

Оболочка xv6 реализует конвейеры, такие как:
```bash
grep fork sh.c | wc -l
```
способом, аналогичным приведенному выше коду (см. *user/sh.c:/case.PIPE*). Дочерний процесс создает канал для соединения левого конца конвейера с правым концом. Затем он вызывает `fork` и `runcmd` для левого конца конвейера и `fork` и `runcmd` для правого конца и ожидает завершения обоих процессов. Правым концом конвейера может быть команда, которая сама включает канал (например, `a | b | c`), который сам создаст два новых дочерних процесса (один для `b` и один для `c`). Таким образом, оболочка может сформировать дерево процессов. Листья этого дерева являются командами, а внутренние узлы - процессами, которые ожидают завершения левого и правого дочерних процессов.

Может показаться, что можно было бы обойтись и без механизма безымянных каналов. Например, команду
```bash
echo hello world | wc
```
можно реализовать и без использования каналов таким образом:
```bash
echo hello world > tmp; wc < tmp
```
Но каналы в этой ситуации имеют по крайней мере три преимущества перед временными файлами. Во-первых, каналы автоматически очищаются. При перенаправлении файла оболочка должна удалить временный файл, когда закончит. Во-вторых, каналы могут передавать произвольно длинные потоки данных, в то время как для перенаправления файла требуется достаточно свободного места на диске для хранения всех данных. В-третьих, конвейеры допускают параллельное выполнение этапов конвейера, в то время как файловый подход требует завершения первой программы до запуска второй.

## Файловая система

Файловая система xv6 предоставляет файлы с данными, которые содержат не интерпретируемые массивы байтов, и каталоги, которые содержат именованные ссылки на файлы и другие каталоги. Каталоги образуют дерево, начинающееся со специального каталога, называемого корневым. Путь, подобный */alpha/beta/gamma*, относится к файлу или каталогу с именем *gamma* внутри каталога с именем *beta*, который внутри каталога с именем *alpha*, который в свою очередь находится в корневом каталоге */*. Пути, которые не начинаются с */*, рассматриваются относительно текущего каталога процесса, который может быть изменен с помощью системного вызова `chdir`. Оба этих фрагмента кода открывают один и тот же файл (при условии, что все задействованные каталоги существуют):
```c++
chdir("/");
chdir("alpha");
chdir("beta");
open("gamma", O_RDONLY);
```
```c++
open("/alpha/beta/gamma", O_RDONLY);
```
Первый фрагмент изменяет текущий каталог процесса на "/alpha/beta" и открывает файл относительно текущего рабочего каталога. Второй фрагмент не ссылается на текущий каталог процесса и не изменяет его.

Xv6 предоставляет системные вызовы для создания файлов и каталогов: системный вызов `mkdir` создает новый каталог, системный вызов `open` с флагом `O_CREATE` создает новый файл данных, а `mknod` создает новый файл устройства. Следующий пример иллюстрирует все три системных вызова
```c++
mkdir("/dir");
fd = open("/dir/file", O_CREATE | O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```
Системный вызов `mknod` создает специальный файл, который ссылается на устройство. С файлом устройства связаны **первичный** *(англ. major)* и **вторичный** *(англ. minor)* номера устройств (два аргумента `mknod`), которые однозначно идентифицируют устройство ядра. Когда процесс позже открывает файл устройства, ядро перенаправляет системные вызовы `read` и `write` в код устройства в ядре вместо файловой системы.

Имя файла является просто ссылкой на сами данные, которые хранятся в ядерном объекте файла, называемым **индексным блоком** *(англ. inode)*. На одну и ту же **inode** может ссылаться несколько имен. Каждая ссылка — это запись в каталоге. Запись содержит имя файла и указатель на **inode**. **Inode** содержит метаданные о файле, включая его тип (файл, каталог или устройство), его длину, расположение содержимого файла на диске и количество ссылок на файл.

Системный вызов `fstat` извлекает информацию из inode, на которую ссылается файловый дескриптор. Системны вызов записывает данные по указателю, переданному в качестве аргумента: в структуру `stat`, определенную в файле *kernel/stat.h*:
```c++
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device

struct stat {
  int dev;     // File system's disk device
  uint ino;    // Inode number
  short type;  // Type of file
  short nlink; // Number of links to file
  uint64 size; // Size of file in bytes
};
```
Системный вызов `link` создает альтернативное имя в файловой системе, ссылающееся на ту же `inode`, что и существующий файл. Этот фрагмент создает новый файл с двумя именами *alpha* и *beta* ссылающимися на него.
```c++
open("alpha", O_CREATE | O_WRONLY);
link("alpha", "beta");
```
Чтение или запись в файл *alpha* будет давать тот же результат, что и чтение или запись в *beta*. После приведенного выше фрагмента кода можно определить, что *alpha* и *beta* ссылаются на один и тот же объект, проверив результат системного вызова `fstat`. Поскольку каждая inode идентифицируется уникальным номером, в обоих случаях `fstat` вернет одинаковый идентификатор (поле `ino` в структуре `stat`), и количество ссылок на inode (поле `nlink`) будет равным 2.

Системный вызов `unlink` удаляет имя файла из файловой системы. В результате выполнения, в inode, соответствующей удалённому имени уменьшается на единицу счетчик ссылок, и если он доходит до нуля, то inode и дисковое пространство, содержащее данные файла, освобождаются. Таким образом, если добавить:
```c++
unlink("alpha");
```
к предыдущему фрагменту кода, inode будет по-прежнему доступна через файл *beta*.

Unix предоставляет утилиты для файловой системы, вызываемые из оболочки как пользовательские программы, например `mkdir`, `ln` и `rm `. Этот дизайн позволяет любому расширить интерфейс командной строки, добавив новые пользовательские программы. Теперь, этот дизайн кажется очевидным, но другие системы, разработанные во времена Unix, часто встраивали такие команды в оболочку (и встраивали оболочку в ядро).

Исключением является `cd`, которая встроена в оболочку *(см. user/sh.c)*. `cd` должна изменить текущий рабочий каталог самой оболочки. Если бы `cd` запускался как обычная команда, то оболочка создала бы дочерний процесс, дочерний процесс запустил бы `cd`, который изменил бы рабочий каталог **дочернего** процесса. Рабочий каталог **родительского** процесса (т.е. оболочки) не изменился бы.

## Настоящий мир

Комбинация **стандартных** файловых дескрипторов, каналов и удобного синтаксиса оболочки в Unix была крупным достижением в написании программ общего назначения, пригодных для множественного использования. Эта идея породила культуру программных **утилит** *(англ. utilities)*, которая во многом обеспечила мощь и популярность Unix, а оболочка стала первым так называемым **скриптовым языком** *(scripting language)*. Интерфейс системных вызовов Unix сохраняется и сегодня в таких системах, как BSD, Linux и macOS.

Интерфейс системных вызовов Unix был стандартизирован с помощью стандарта **Переносимого Интерфейса Операционных Систем** *(англ. Portable Operating System Interface — POSIX)*. Xv6 **не является** POSIX совместимой: в ней отсутствуют многие системные вызовы (включая базовые, такие как `lseek`), и многие системные вызовы, xv6 предоставляет, не до конца следуют стандарту POSIX. Основные цели для xv6 - доступность и ясность при обеспечении простого UNIX-подобного интерфейса системных вызовов. Некоторые энтузиасты расширили xv6, добавив еще несколько системных вызовов и простую библиотеку си для запуска базовых Unix-программ. Современные ядра, однако, предоставляют гораздо больше функционала и гораздо больше служб ядра, чем xv6. Например, они поддерживают сетевые, оконные системы, потоки пользовательского уровня, драйверы для многих устройств и так далее. Современные ядра развиваются непрерывно и быстро и предлагают множество функций, выходящих за рамки POSIX.

Unix обеспечивает единообразный доступ к разным типам ресурсов (файлам, каталогам и устройствам) с помощью единого интерфейса файлов и файловых дескрипторов. Эта идея может быть обобщена и на еще больше видов ресурсов. Хорошим примером является операционная система [Plan 9](PLAN_9), которая применил концепцию **ресурсы — это файлы** к сетям, графике и многому другому. Однако большинство операционных систем, производных от Unix, не пошли по этому пути.

Файловая система и файловые дескрипторы были мощными абстракциями. Несмотря на это, существуют и другие модели интерфейсов операционной системы. Например, **Multics**, предшественник Unix, абстрагировал файловое хранилище таким образом, что оно выглядело как память, создавая совершенно другой вид интерфейса. Сложность дизайна Multics оказала непосредственное влияние на разработчиков Unix, которые стремились создать что-то более простое.

Xv6 не дает представления о пользователях или о защите одного пользователя от другого; в терминах Unix все процессы xv6 запускаются от имени пользователя root.

В этой книге рассматривается, как в xv6 реализуется Unix-подобный интерфейс, но идеи и концепции применимы не только к Unix. Любая операционная система должна предоставлять процессам оборудование *(англ. hardware)*, изолировать процессы друг от друга и предоставлять механизмы для контролируемого взаимодействия между процессами. После изучения xv6 вы должны быть в состоянии взглянуть на другие, более сложные операционные системы и увидеть концепции, лежащие в основе xv6, также и в этих системах.

## Упражнения

Напишите программу, которая использует системные вызовы UNIX для передачи байта между двумя процессами по паре каналов, по одному в каждом направлении. Измерьте производительность программы в количествах обменов в секунду.
