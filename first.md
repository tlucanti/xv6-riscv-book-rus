# Организация операционных систем

Ключевым требованием к операционной системе является поддержка нескольких действий одновременно. Например, с помощью интерфейса системных вызовов, описанного в главе [UNIX][CHAPTER_UNIX] процесс может создавать новые процессы с помощью системного вызова  `fork`. Операционная система должна распределять ресурсы компьютера **по времени** *(англ. time-share)* между этими процессами. Например, даже если процессов больше, чем аппаратных процессоров, операционная система должна гарантировать, что все процессы получат возможность выполняться. Операционная система также должна обеспечить **изоляцию** *(англ. isolation)* между процессами. То есть, если в одном процессе есть ошибка или вредоносный код, это не должно влиять на другие процессы. Полная изоляция, однако, слишком жесткая мера, поскольку для процессов должна быть возможность намеренного взаимодействия. Примером могут служить конвейеры. Таким образом, операционная система должна удовлетворять трем требованиям: мультиплексирование оборудования, изоляция процессов и их взаимодействие.

В этой главе дается обзор того, как организованы операционные системы чтобы иметь возможность выполненять эти три требования. Оказывается, есть много способов достигнуть этого, но данный текст посвящен основным тенденциям, сосредоточенным вокруг **монолитного ядра** *(англ. monolithic kernel)*, которое используется многими Unix-подобными операционными системами. В этой главе также приводится обзор устройства процессов в xv6, и процедура запуска первого процесса при старте xv6.

Xv6 написана для **многоядерных** *(англ. multi-core)* микропроцессоров с архитектурой RISC-V, и большая часть низкоуровневой функциональности ядра (например, реализация процессов) специфична для этой архитектуры.

> Под **многоядерностью** в этом тексте подразумевается несколько процессоров, которые используют общую память, но работают параллельно, каждый со своим собственным набором регистров. В этом тексте иногда будет использоваться термин **многопроцессорный** *(англ. multiprocessor)* как с тем же значением что и **многоядерный** *(англ. multi-core)*, хотя **многопроцессорный** также может более конкретно относиться к компьютеру с несколькими различными процессорными чипами.

Xv6 написана для *64*-битных RISC-V процессоров, это значит, что все регистры и адреса памяти имеют размер *64* бита (или *8* байт). Это означает, что в коде ядра переменные типа `long` и указатели имеют размер *64* бита, а тип `int` - *32* бита. Эта книга предполагает, что читатель имеет небольшой опыт программирования на машинном уровне для какой-либо архитектуры, и будет знакомить с концептами, специфичными для RISC-V, по мере их появления. Полезным справочником по RISC-V будет *[The RISC-V Reader: An Open Architecture Atlas](RISCV_READER_BOOK)*. **Архитектура набора команд** *(англ. Instruction Set Architecture - ISA)* для [пользовательского режима](USER_LEVEL_ISA) и [привилегированного режима](PRIVILEGED_ARCHITECTURE_ISA) являются официальными спецификациями.

Центральный процессор в полноценном компьютере окружен периферией, большая часть которой является оборудованием ввода-вывода. Xv6 написан для управления перефирией, имитируемой программой `qemu` иммитурующей оборудование с помощью опции `-machine virt`. Эта опция включает в себя оперативную память, ПЗУ, содержащее загрузочный код, клавиатуру/экран пользователя и диск для хранения.

> `qemu` - программа эмулятор. Она эмулирует процессор компьютера посредством динамической двоичной трансляции и предоставляет набор различных аппаратных средств и моделей устройств для машины, позволяя ей запускать различные гостевые операционные системы.

## Абстрагирование физических ресурсов

Первый вопрос, который возникает, сталкиваясь с операционной системой - зачем она вообще нужна? Например, можно было бы реализовать системные вызовы из [таблицы 1.1](SYSCALLS_TABLE) как библиотеку, которую приложения будут линковать к себе. В этом плане каждое приложение могло бы даже иметь свою собственную библиотеку, адаптированную к его потребностям. Приложения могут напрямую взаимодействовать с аппаратными ресурсами и использовать эти ресурсы наилучшим для приложения образом (например, для достижения высокой или предсказуемой производительности). Некоторые операционные системы для **встраиваемых** *(англ. embedded)* устройств или систем **реального времени** *(англ. real-time)*  организованы таким образом.

> Вынесение функционала операционной системы в библиотеку называется **экзоядром** *(англ. exokernel)*.

> Встраиваемые системы используют **операционные системы реального времени** *(англ. Real Time Operating Systems - RTOS)*, цель которых обеспечить гарантии на время исполнения требуемых задач.

Недостатком этого подхода с библиотекой является то, что, если запущено более одного приложения, то они должны вести себя порядочно. Например, каждое приложение должно периодически освобождать центральный процессор, чтобы могли запускаться другие приложения. Такая схема разделения времени может быть приемлемой, если все приложения доверяют друг другу и не имеют ошибок. Для приложений более типична противоположная ситуация, поэтому часто требуется более сильная изоляция, чем обеспечивает такая схема.

Для достижения надежной изоляции полезно запретить приложениям прямой доступ к чувствительным аппаратным ресурсам и вместо этого использовать абстракцию в виде служб. Например, приложения Unix взаимодействуют с диском только посредством системных вызовов файловой системы `open`, `read`, `write` и `close`, вместо прямого чтения и записи на диск. Это обеспечивает приложению возможность использования имен путей и позволяет операционной системе управлять диском. Даже в тех случаях  когда изоляция не является необходимой, программы, которые взаимодействуют намеренно (или просто хотят не мешать друг другу), скорее всего, сочтут файловую систему более удобной абстракцией, чем прямое использование диска.

Аналогичным образом, Unix неявно переключает аппаратные *процессоры* между программными *процессами*, сохраняя и восстанавливая состояние регистров по мере необходимости, так что приложениям не нужно знать о разделении процессоров по времени. Эта прозрачность позволяет операционной системе совместно использовать процессоры, даже если некоторые приложения находятся в бесконечных циклах.

В качестве другого примера, процессы Unix используют системный вызов `exec` для создания своего адресного пространства вместо прямого взаимодействия с физической памятью. Это позволяет операционной системе решать, куда поместить процесс в физической памяти, а при нехватке памяти операционная система может даже сохранить некоторую часть данных процесса на диске. `exec` также удобен в использовании, так как использует файловую систему для хранения исполняемых файлов программ.

Многие формы взаимодействия между процессами Unix осуществляются с помощью файловых дескрипторов. Файловые дескрипторы не только абстрагируют многие детали (например, где хранятся данные в канале или файле), они также определены таким образом, который упрощает взаимодействие. Например, если одно приложение в конвейере команд оболочки выходит из строя, ядро подаёт сигнал об окончании файла для следующего процесса в конвейере.

Интерфейс системных вызовов (таб. 1)[TABLE_SYSCALLS] тщательно разработан, чтобы обеспечить как удобство программиста, так и возможность надежной изоляции. Интерфейс Unix - не единственный способ абстрагирования ресурсов, но он зарекомендовал себя как очень хороший.

## Пользовательский режим, режим супервизора, системные вызовы

Для надежной изоляции требуется строгая граница между приложениями и операционной системой. Если в приложении возникает ошибка, недопустимо, чтобы вся операционная система завершала работу с ошибкой или другие приложения из-за этого тоже завершали работу с ошибкой. Вместо этого операционная система должна иметь возможность очистить сбойное приложение и продолжить запуск других приложений. Чтобы добиться надежной изоляции, операционная система должна не допустить, чтобы приложения могли изменять (или даже считывать) структуры данных и инструкции операционной системы и чтобы приложения не могли получать доступ к памяти других процессов.

Центральные процессоры обеспечивают строгую изоляцию на аппаратном уровне. Например, RISC-V имеет три режима, в которых центральный процессор может выполнять инструкции: машинный режим, режим супервизора и пользовательский режим. Инструкции, выполняемые в машинном режиме, имеют полный контроль над системой и в основном предназначен для настройки компьютера. Процессор изначально запускается в машинном режиме. Xv6 выполняет несколько инструкций в машинном режиме, а затем переходит в режим супервизора.

В режиме супервизора процессору разрешено выполнять привилегированные инструкции: например, включение и отключение прерываний, чтение и запись регистра адреса таблицы страниц, и т.д. Если приложение в пользовательском режиме пытается выполнить привилегированную инструкцию, то центральный процессор не выполняет инструкцию, а переключается в режим супервизора, чтобы код в режиме супервизора мог завершить работу приложения, потому что оно сделало что-то, чего не должно было делать. [Рисунок][???] в главе UNIX иллюстрирует эту организацию. Приложение может выполнять только инструкции пользовательского режима (например, сложение чисел и т.д.) и, как говорят, выполняется в пространстве пользователя, в то время как программное обеспечение в режиме супервизора также может выполнять привилегированные инструкции и, как говорят, выполняется в пространстве ядра. Программное обеспечение, работающее в пространстве ядра (или в режиме супервизора), называется ядром.

Приложение, которое хочет вызвать ядро (например, с помощью системного вызова `read` в xv6), должно совершить переход в ядро. приложение **не может** вызвать функции ядра напрямую. Процессоры предоставляют специальную инструкцию, которая переключает процессор из пользовательского режима в режим супервизора и переводит исполнение в точку входа, указанную ядром (RISC-V предоставляет для этой цели инструкцию `ecall`). Как только центральный процессор переключится в режим супервизора, ядро может затем произвести проверку аргументов системного вызова (например, проверить, принадлежит ли адрес, переданный в системный вызов приложению), разрешено ли приложению выполнять запрошенную операцию (например, проверить есть ли доступ к  указанному файлу), и на основании проверок выполнить системыный вызов, или запретить выполнение. Важно, чтобы именно ядро контролировало точку входа для перехода в режим супервизора, иначе, вредоносное приложение могло бы, например, проникнуть в ядро в точку после проверки аргументов.

## Организация ядра

Ключевой вопрос проектирования операционных систем заключается в том, какая часть операционной системы должна запускаться в режиме супервизора. Одна из возможностей заключается в том, что вся операционная система находится в ядре, так что реализации всех системных вызовов выполняются в режиме супервизора. Такая организация называется **монолитным ядром** *(англ. monolithic kernel)*.

При таком способе организации вся операционная система работает с полными аппаратными привилегиями. Такая организация удобна тем, что разработчику ОС не нужно решать, какой части операционной системы не нужны полные аппаратные привилегии. Кроме того, различным частям операционной системы проще взаимодействовать. Например, операционная система может иметь общий буфер, который может совместно использоваться как файловой системой, так и системой виртуальной памяти.

Недостатком монолитной организации является то, что интерфейсы взаимодействия между различными частями операционной системы обычно сложны (как мы увидим далее), и поэтому разработчику операционной системы легко совершить ошибку. В монолитном ядре ошибка является фатальной, поскольку ошибка в режиме супервизора часто приводит к выходу из строя ядра. При сбое ядра компьютер перестает работать, и, следовательно, все приложения также выходят из строя. В таком случае  компьютер может только перезагрузиться, чтобы начать снова.

Чтобы снизить риск ошибок в ядре, разработчики ОС могут минимизировать объем кода операционной системы, который выполняется в режиме супервизора, и выполнять основную часть операционной системы в пользовательском режиме. Такая организация ядра называется **микроядром** *(англ. microkernel)*.

[FIG_MICROKERNEL][???]
Микроядро со службой файловой системы

На [рисунке][FIG_MICROKERNEL] иллюстрируется данная конструкция микроядра: файловая система работает как процесс пользовательского уровня. Службы операционной системы, работающие как процессы, называются **серверами** *(англ. servers)*. Чтобы позволить приложениям взаимодействовать с файловым сервером, ядро предоставляет механизм **межпроцессного взаимодействия** *(англ. inter-process communication)*  для отправки сообщений от одного процесса пользовательского режима к другому. Например, если приложение, такое как оболочка, хочет прочитать или записать файл, оно отправляет сообщение службе файловый системы и ожидает ответа.

В микроядре интерфейс ядра состоит из нескольких низкоуровневых функций для запуска приложений, отправки сообщений, доступа к аппаратному обеспечению и т.д. Такая организация позволяет ядру быть относительно простым, поскольку большая часть операционной системы находится на пользовательского уровне.

В реальном мире популярны как монолитные ядра, так и микроядра. Многие Unix ядра имеют монолитную структуру. Например, Linux имеет монолитное ядро, хотя некоторые функции ОС выполняются как службы пользовательского уровня (например, графическая оконная система). Linux обеспечивает высокую производительность приложений, требующих интенсивной работы с операционной системой, отчасти потому, что подсистемы ядра могут быть тесно интегрированы.

Операционные системы, такие как Minix, L4 и QNX, имеют микроядерную организацию с пользовательскими службами в виде серверов. Они широко используются во встраиваемых системах. Модификация ядра L4 -- [seL4][LINK_SEL4] была достаточно компактной, чтобы его можно было проверить на безопасность памяти и другие свойства безопасности с помощью метода **[формальной верификации][LINK_FORMAL_VERIFICATION]** *(англ. formal verification)* 

Среди разработчиков операционных систем ведется много споров о том, какая организация лучше, и нет явного подтверждения того, что какая-либо лучше. Кроме того, это во многом зависит от того, что понимать под словом *лучше*: более высокая производительность, меньший размер кода, надежность ядра, надежность всей операционной системы (включая службы пользовательского уровня) и т.д.

С точки зрения этой книги, микроядерные и монолитные операционные системы разделяют основные идеи. Они реализуют системные вызовы, они используют таблицы страниц, они обрабатывают прерывания, они поддерживают процессы, они используют блокировки для управления параллелизмом, они реализуют файловую систему и т.д. Эта книга посвящена этим ключевым идеям.

Xv6 реализована как монолитное ядро, также как и большинство Unix-подобных операционных систем. Таким образом, интерфейс ядра xv6 соответствует интерфейсу операционной системы, а ядро реализует полноценную операционную систему. Поскольку xv6 предоставляет не так много сервисов - её ядро меньше, чем у некоторых микроядер, но концептуально xv6 монолитна.

## Программный код: организация xv6.

| File | Description |
| ---- | ----------- | 
| *bio.c* | Кэш дисковых блоков для файловой системы |  
| *console.c* | Подключение к клавиатуре и экрану пользователя |
| *entry.S* | Первоначальные инструкции при запуске системы |
| *exec.c* | Системный вызов exec() |
| file.c | Поддержка файловых дескрипторов |
| fs.c | файловая система |
| kalloc.c | Аллокатор физических страниц |
| kernelvec.S | Обработчики исключений и прерываний по таймеру |
| log.c | Журналирование файловой системы и восстановление после сбоев |
| main.c | Управление и инициализация других модулей во время загрузки |
| pipe.c | Каналы |
| plic.c | Контроллер прерываний RISC-V |
| printf.c | Форматированный вывод в консоль |
| proc.c | Процессы и диспетчеризация |
| sleeplock.c |  Блокировки, освобождающие CPU для других задач |
| spinlock.c | Блокировки, не освобождающие процессор |
| start.c | Ранний загрузочный код в машинном режиме |
| string.c | Библиотека си-строк |
| swtch.S | Переключение контекста |
| syscall.c | Распределение системных вызовов функциям обработчикам |
| sysfile.c | Системные вызовы, связанные с файлами |
| sysproc.c | Системные вызовы, связанные с процессами |
| trampoline.S | Ассемблерный код для переключения между пользователем и ядром |
| trap.c | Код для обработки и возврата из исключений и прерываний |
| uart.c | UART драйвер последовательного консольного устройства |
| virtio_disk.c | Драйвер дискового устройства |
| vm.c | Управление таблицами страниц и адресными пространствами |

Исходный код ядра xv6 находится в подкаталоге *kernel/*. Исходный код разделен на файлы в соответствии с приблизительным представлением о модульности. Файлы перечислены в [Таблице 1]. Интерфейсы между модулями определены в файле *defs.h*.

## Обзор процессов

Единицей изоляции в xv6 (как и в других Unix системах) является **процесс**. Абстракция процесса не позволяет одному процессу взломать или подсмотреть за памятью, процессором, файловыми дескрипторами и т.д. другого процесса. Это также предотвращает разрушение самого ядра процессом, так что процесс не может нарушить механизмы изоляции ядра. Ядро должно тщательно реализовывать абстракцию процесса, поскольку неисправное или вредоносное приложение может обманом заставить ядро или аппаратное обеспечение сделать что-то плохое (например, обойти изоляцию). Механизмы, используемые ядром для реализации процессов, включают флаг режима пользователя/супервизора, адресные пространства и разделение потоков по времени.

Чтобы обеспечить изоляцию, абстракция процесса создает у программы иллюзию того, что у нее есть свой собственный компьютер. Процесс предоставляет программе то, что с ее точки зрения выглядит как система личной памяти, или **адресное пространство** *(англ. address space)*, которое другие процессы не могут считывать или записывать. Процесс также предоставляет программе то, что, с ее точки зрения, является ее собственным процессором для выполнения инструкций программы.

Xv6 использует табличную организацию страниц (которая реализуются аппаратно), чтобы предоставить каждому процессу его собственное адресное пространство. Таблица страниц RISC-V преобразует (или **сопоставляет** *(англ. map)*) **виртуальный адрес** *(англ. virtual address)* (адрес, которым оперируют инструкции RISC-V) в **физический адрес** *(англ. physical address)* (адрес, который ЦПУ отправляет в устройство памяти).

[FIG_LAYOUT][???]
Расположение элементов виртуального адресного пространства процесса xv6

Xv6 хранит отдельную таблицу страниц для каждого процесса, которая определяет адресное пространство этого процесса. Как показано на [рисунке][FIG_LAYOUT], адресное пространство включает в себя **пользовательскую память** процесса начиная с нулевого виртуального адреса. В адресном пространстве сначала идут инструкции, затем глобальные переменные, потом стек и, наконец, область **кучи** (для **malloc**), которую процесс может расширять по мере необходимости. Существует ряд факторов, которые ограничивают максимальный размер адресного пространства процесса: указатели в RISC-V имеют ширину *64* бита, но аппаратное обеспечение использует только младшие *39* бит при поиске виртуальных адресов в таблицах страниц, а xv6 использует только *38* из этих *39* бит. Таким образом, максимальный адрес равен `2^38 - 1 = 0x3fffffffff`. Он определен макросом **MAXVA** *(см. kernel/riscv.h)*. В верхней части адресного пространства xv6 резервирует страницу для **трамплина* *(англ. trampoline)* и страницу, отображающую **трапфрейм** *(англ trapframe)* процесса. Xv6 использует эти две страницы для перехода в ядро и обратно. страница трамплина содержит код для перехода в ядро и выхода из него, а мапинг *(англ. mapping)* трапфрейма необходим для сохранения/восстановления состояния пользовательского процесса, как будет объяснено в главе [Прерывания][CH_TRAP].

Ядро xv6 поддерживает данные о состоянии каждого процесса. Состояние процесса состоит из многих элементов, которые объединены в структуру `struct proc` (см. *kernel/proc.h*). Наиболее важными элементами состояния процесса в ядре являются таблица страниц, стек ядра и состояние выполнения. Мы будем использовать обозначение `p->xxx` для обозначения полей структуры `struct proc`. Например, `p->pagetable` - это указатель на таблицу страниц процесса.

У каждого процесса есть **поток исполнения** (или просто **поток** *(англ. thread)*), который выполняет инструкции процесса. Поток может быть приостановлен, а затем возобновлен. Для прозрачного переключения между процессами ядро приостанавливает текущий запущенный поток и возобновляет поток другого процесса. Большая часть состояния потока (локальные переменные, адреса возврата из функций) хранится на стеке потока. У каждого процесса есть два стека: пользовательский стек и стек ядра (поле `p->kstack`). Когда процесс выполняет инструкции пользователя, используется только его пользовательский стек, а стек ядра пуст. Когда процесс входит в ядро (для системного вызова или при прерывании), код ядра выполняется на стеке ядра процесса. Пока процесс находится в ядре, его пользовательский стек по-прежнему содержит сохраненные данные, но не используется. Поток процесса попеременно использует свой пользовательский стек и стек ядра. Стек ядра отделен (и защищен от пользовательского кода), так что ядро может выполняться, даже если процесс разрушил свой пользовательский стек.

Процесс может выполнить системный вызов, выполнив инструкцию RISC-V `ecall`. Эта команда повышает уровень привилегий процессора и изменяет программный счетчик на точку входа, определенную ядром. Код в точке входа переключается на стек ядра и выполняет инструкции ядра, которые отвечают за обработку системного вызова. Когда системный вызов завершается, ядро переключается обратно на пользовательский стек и возвращается в пространство пользователя, вызывая команду `sret`, которая понижает уровень привилегий процессора и возобновляет выполнение пользовательских инструкций сразу после команды системного вызова. Поток процесса может быть остановлен блокирующей операцией в ядре для ожидания ввода-вывода и возобновлен с того места, где он был прерван, когда ввод-вывод завершится.

Поле `p->state` указывает, аллоцирован ли процесс, готов к запуску, выполняется, ожидает ввода-вывода или завершает работу.

Поле `p->pagetable` содержит таблицу страниц процесса в формате, который ожидает аппаратное обеспечение RISC-V. Xv6 сообщает блоку управления памятью, что для трансляции адресов нужно использовать `p->pagetable` процесса при выполнении этого процесса в пространстве пользователя. Таблица страниц процесса также служит для отслеживания физических страниц, выделенных для хранения памяти процесса.

Таким образом, процесс сочетает в себе две идеи: адресное пространство, создающее иллюзию целиком собственной памяти, и поток, создающий иллюзию собственного центрального процессора. В xv6 процесс состоит из одного адресного пространства и одного потока. В реальных операционных системах процесс может иметь более одного потока, что позволяет использовать преимущества нескольких процессоров.

## Программный код: запуск xv6, первый процесс и системный вызов

Чтобы старт xv6 стал более ясным, в этой секции будет рассказано о том, как ядро запускает первый процесс. В последующих главах более подробно будут описаны механизмы, которые представлены в этой секции.

Когда компьютер с RISC-V процессором включается, он инициализирует CPU и запускает загрузчик, который хранится в памяти, доступной только для чтения. Загрузчик загружает код ядра xv6 в память. Затем, в машинном режиме, центральный процессор начинает исполнение xv6 с метки `_entry` (см. *kernel/entry.S*). В машинном режиме RISC-V запускается с отключенной страничной организацией и виртуальной памятью. Таким образом обращения в память происходят напрямую, по физическим адресам.

Загрузчик загружает ядро xv6 в память по физическому адресу *0x80000000*. Причина, по которой он помещает ядро в *0x80000000*, а не в *0x0*, заключается в том, что диапазон адресов *0x0 - 0x80000000* содержит **отображенные в память** *(англ. memory mapped)* устройства ввода-вывода.

Инструкции, находящиеся по метке `_entry` настраивают стек, чтобы xv6 мог запускать код на Cи. Xv6 объявляет пространство для стека ядра с помощью переменной `stack0`, (см. *kernel/start.c*). Каждому ядру процессора выделяется *4096* байт стека. Код по метке `_entry` загружает в регистр указателя стека sp адрес stack0+4096, который указывает на конец стекового пространства, поскольку стек в RISC-V растет вниз. Теперь, когда в ядре есть стек, вызывается Cи-функция `start` (см. *kernel/start.c*).

Функция `start` выполняет начальную конфигурацию, которая разрешена только в машинном режиме, а затем переключается в режим супервизора. Чтобы перейти в режим супервизора, RISC-V предоставляет инструкцию `mret`. Эта инструкция возвращает процессор из машинного режима в предыдущий до перехода в машинный. Чаще всего она используется после попадания в машинный режим из режима супервизора (например, после обращения к аппаратуре), для возврата обратно в режим супервизора. Но в момент исполнения функции `start` такого перехода из режима супервизора в машинный режим не было, поэтому функция `start` настраивает все так, как если бы он был: устанавливает предыдущий режим привилегий на **supervisor** в регистре `mstatus`. Далее устанавливается адрес возвращения. Адрес выставляется, записывая адрес функции `main` в регистр `mepc`. Потом режим страничной организации отключается для режима супервизора, записывая *0* в регистр таблицы страниц `satp`, чтобы при переходе в режим супервизора сразу не получить ошибку обращения к памяти, так как таблица страниц ещё не настроена. Далее функция `start` делегирует все прерывания и исключения в режим супервизора.

Перед переходом в режим супервизора функция `start` выполняет еще одну задачу: программирует таймер для генерации периодических прерываний. После завершения этой работы `start` переходит в режим супервизора, вызывая инструкцию `mret`. Это приводит к изменению значения программного счетчика на адрес функции `main` (см. *kernel/main.c*).

После того, как функция `main` (см. *kernel/main.c*) инициализирует несколько устройств и подсистем, xv6 создает первый процесс, вызывая функцию `userinit` (см. *kernel/proc.c*). Первый процесс выполняет небольшую программу, написанную на RISC-V ассемблере, которая выполняет первый системный вызов в xv6 (см. *user/initcode.S*). Программа загружает номер для системного вызова `exec` - макрос SYS_EXEC (см. *kernel/syscall.h*) в регистр `a7`, а затем вызывает `ecall` для повторного входа в ядро.

Ядро использует номер в регистре `a7` в функции `syscall` (см. *kernel/syscall.c*) для вызова нужной функции обрабатывающей системный вызов. Таблица системных вызовов (см. *kernel/syscall.c*) сопоставляет значение `SYS_EXEC` функции `sys_exec`, которую вызывает ядро. Как мы видели в главе UNIX, **exec** заменяет память и регистры текущего процесса новой программой (в данном случае **init**).

Как только ядро завершит обработку системного вызова `exec`, оно возвращается в пространство пользователя в процесс **init**. **init** (см. user/init.c) при необходимости создает новый файл консольного устройства, а затем открывает его с файловыми дескрипторами *0*, *1* и *2*. Затем запускается командная строка. Система запущена.

## Модель безопасности

Вы можете задаться вопросом, как операционная система справляется с ошибками или вредоносным кодом. Поскольку справиться со злым умыслом гораздо сложнее, чем со случайными ошибками, разумно рассматривать эту тему как относящуюся к безопасности. Вот общий обзор типичных допущений и целей в области безопасности при разработке операционной системы.

Операционная система должна быть готовой к тому, что пользовательский код процесса сделает все возможное, чтобы разрушить ядро или другие процессы. Пользовательский код может попытаться разыменовать указатели за пределами разрешенного адресного пространства. Он может попытаться выполнить любые инструкции RISC-V, даже те, которые не предназначены для пользовательского кода, или вообще не существуют. Он может попытаться прочитать и записать любой управляющий регистр RISC-V. Он может попытаться получить прямой доступ к аппаратному обеспечению устройства. Он может передавать системным вызовам хитроумные значения в попытке заставить ядро выйти из строя или совершить какую-нибудь глупость. Цель ядра - ограничить все пользовательские процессы так, чтобы все, что они могли делать, - это читать/записывать/выполнять данные в своей собственной пользовательской памяти, использовать 32 универсальных регистра RISC-V, и воздействовать на ядро и другие процессы только так, как это предусмотрено системными вызовами. Ядро должно предотвращать любые другие действия. Обычно это является обязательным требованием при разработке ядра.

Требования к собственному коду ядра совершенно иные. Предполагается, что код ядра написан добросовестными программистами. Ожидается, что в коде ядра не будет ошибок и, безусловно, не будет ничего вредоносного. Это предположение влияет на то, как мы анализируем код ядра. Например, существует множество внутренних функций ядра (например, **спинлоки** *(англ. spin lock)*, которые могут вызвать серьезные проблемы, если код ядра будет использовать их неправильно. При рассмотрении любого конкретного фрагмента кода ядра мы полагаем, что код ядра в целом написан правильно и соответствует всем правилам использования собственных функций и структур данных ядра. Предполагается, что на аппаратном уровне процессор RISC-V, оперативная память, диск и т.д. работают так, как указано в документации, без каких-либо аппаратных ошибок.

Конечно, в реальной жизни все не так просто. Трудно предотвратить, чтобы хитроумный пользовательский код не делал систему непригодной для использования (или вызывал панику), потребляя ресурсы, защищенные ядром -- дисковое пространство, процессорное время, места в таблице процессов и т.д. Обычно невозможно написать код или спроектировать оборудование без ошибок. Если авторы вредоносного пользовательского кода знают об ошибках в ядре или оборудовании, они будут их эксплуатировать. Даже в развитых, широко используемых ядрах, таких как Linux люди постоянно обнаруживают новые [уязвимости][LINUX_BUGLIST]. Стоит предусмотреть в ядре средства защиты от возможных ошибок: проверки, соответствие типов, страницы защиты стека и т.д. Наконец, различие между кодом пользователя и ядра иногда размыто: некоторые процессы привилегированного уровня могут предоставлять жизненно необходимые услуги и фактически быть частью операционной системы, а в некоторых операционных системах код привилегированного пользователя может вставлять новый код в ядро (как в случае с загружаемыми модулями ядра Linux).

## Настоящий мир

Большинство операционных систем используют концепцию процессов, и большинство процессов работают аналогично тем что в xv6. Однако современные операционные системы поддерживают несколько потоков в рамках процесса, что позволяет одному **процессу** использовать несколько **процессоров**. Поддержка нескольких потоков в рамках одного процесса включает в себя довольно много механизмов, которые xv6 не поддерживает, включая потенциальные изменения интерфейса (например, системный вызов `clone` в Linux - альтернатива системному вызову `fork`), чтобы контролировать, какие аспекты процесса будут совместно использоваться потоками.

## Упражнения

Добавьте в xv6 системный вызов, который возвращает объем доступной свободной памяти

## Источники
